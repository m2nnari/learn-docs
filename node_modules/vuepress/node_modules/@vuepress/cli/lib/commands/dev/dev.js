"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.dev = void 0;
const chokidar = require("chokidar");
const core_1 = require("@vuepress/core");
const utils_1 = require("@vuepress/utils");
const config_1 = require("../../config");
const handlePageAdd_1 = require("./handlePageAdd");
const handlePageChange_1 = require("./handlePageChange");
const handlePageUnlink_1 = require("./handlePageUnlink");
const resolveDevAppConfig_1 = require("./resolveDevAppConfig");
const log = utils_1.debug('vuepress:cli/dev');
const dev = async (sourceDir = '.', commandOptions = {}) => {
    log(`commandOptions:`, commandOptions);
    if (process.env.NODE_ENV === undefined) {
        process.env.NODE_ENV = 'development';
    }
    // resolve app config from cli options
    const appConfig = resolveDevAppConfig_1.resolveDevAppConfig(sourceDir, commandOptions);
    // resolve user config file
    const userConfigPath = commandOptions.config
        ? config_1.resolveUserConfigPath(commandOptions.config)
        : config_1.resolveUserConfigConventionalPath(appConfig.source);
    log(`userConfigPath:`, userConfigPath);
    const userConfig = await config_1.loadUserConfig(userConfigPath);
    // create vuepress app
    const app = core_1.createApp({
        // use cli options to override config file
        ...userConfig,
        ...appConfig,
    });
    // use user-config plugin
    app.use(config_1.transformUserConfigToPlugin(app, userConfig));
    // clean temp and cache
    if (commandOptions.cleanTemp === true) {
        utils_1.logger.info('Cleaning temp...');
        await utils_1.fs.remove(app.dir.temp());
    }
    if (commandOptions.cleanCache === true) {
        utils_1.logger.info('Cleaning cache...');
        await utils_1.fs.remove(app.dir.cache());
    }
    // initialize and prepare
    utils_1.logger.info('Initializing VuePress and preparing data...');
    await app.init();
    await app.prepare();
    // start dev server
    const close = await app.dev();
    // do not watch files if `watch` is set to `false`
    if (commandOptions.watch === false) {
        return;
    }
    // all watchers
    const watchers = [];
    // restart dev command
    const restart = async () => {
        await Promise.all([
            // close all watchers
            ...watchers.map((item) => item.close()),
            // close current dev server
            close(),
        ]);
        // restart dev command
        await exports.dev(sourceDir, commandOptions);
        utils_1.logger.tip(`dev server has restarted, please refresh your browser`);
    };
    // watch page files
    const pagesWatcher = chokidar.watch(app.options.pagePatterns, {
        cwd: app.dir.source(),
        ignoreInitial: true,
    });
    pagesWatcher.on('add', (filePathRelative) => {
        utils_1.logger.info(`page ${utils_1.chalk.magenta(filePathRelative)} is created`);
        handlePageAdd_1.handlePageAdd(app, app.dir.source(filePathRelative));
    });
    pagesWatcher.on('change', (filePathRelative) => {
        utils_1.logger.info(`page ${utils_1.chalk.magenta(filePathRelative)} is modified`);
        handlePageChange_1.handlePageChange(app, app.dir.source(filePathRelative));
    });
    pagesWatcher.on('unlink', (filePathRelative) => {
        utils_1.logger.info(`page ${utils_1.chalk.magenta(filePathRelative)} is removed`);
        handlePageUnlink_1.handlePageUnlink(app, app.dir.source(filePathRelative));
    });
    watchers.push(pagesWatcher);
    // watch user config file
    if (userConfigPath) {
        const configWatcher = chokidar.watch(userConfigPath, {
            cwd: process.cwd(),
            ignoreInitial: true,
        });
        configWatcher.on('change', (configFile) => {
            utils_1.logger.info(`config ${utils_1.chalk.magenta(configFile)} is modified`);
            restart();
        });
        watchers.push(configWatcher);
    }
    await app.pluginApi.hooks.onWatched.process(app, watchers, restart);
};
exports.dev = dev;
//# sourceMappingURL=dev.js.map